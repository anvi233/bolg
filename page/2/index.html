<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MY BOLG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="MY BOLG">
<meta property="og:url" content="http://jumpu.top/page/2/index.html">
<meta property="og:site_name" content="MY BOLG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MY BOLG">
  
    <link rel="alternate" href="/atom.xml" title="MY BOLG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">MY BOLG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://jumpu.top"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="layout-MongoDB doucment" class="article article-type-layout" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/15/MongoDB doucment/" class="article-date">
  <time datetime="2017-02-15T07:47:52.000Z" itemprop="datePublished">2017-02-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/02/15/MongoDB doucment/">database_choice</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://lib.csdn.net/base/mongodb" target="_blank" rel="external">MongoDB知识库 by CSDN</a></p>
<p><a href="http://lib.csdn.net/base/mongodb/structure" target="_blank" rel="external">MongoDB知识图谱 by CSDN</a></p>
<p><a href="http://www.jb51.net/article/48217.htm" target="_blank" rel="external">MongoDB常用操作命令</a></p>
<p><a href="http://281816327.blog.51cto.com/907015/1611295/" target="_blank" rel="external">rs常用操作命令</a></p>
<p><a href="http://chuansong.me/n/1928604" target="_blank" rel="external">2PC相关1</a></p>
<p><a href="https://docs.mongodb.com/manual/tutorial/perform-two-phase-commits/" target="_blank" rel="external">2PC相关2</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">&gt; db.help();</div><div class="line">DB methods:</div><div class="line">        db.adminCommand(nameOrDocument) - switches to &apos;admin&apos; db, and runs comma</div><div class="line">nd [ just calls db.runCommand(...) ]</div><div class="line">        db.auth(username, password)</div><div class="line">        db.cloneDatabase(fromhost)</div><div class="line">        db.commandHelp(name) returns the help for the command</div><div class="line">        db.copyDatabase(fromdb, todb, fromhost)</div><div class="line">        db.createCollection(name, &#123; size : ..., capped : ..., max : ... &#125; )</div><div class="line">        db.createView(name, viewOn, [ &#123; $operator: &#123;...&#125;&#125;, ... ], &#123; viewOptions</div><div class="line">&#125; )</div><div class="line">        db.createUser(userDocument)</div><div class="line">        db.currentOp() displays currently executing operations in the db</div><div class="line">        db.dropDatabase()</div><div class="line">        db.eval() - deprecated</div><div class="line">        db.fsyncLock() flush data to disk and lock server for backups</div><div class="line">        db.fsyncUnlock() unlocks server following a db.fsyncLock()</div><div class="line">        db.getCollection(cname) same as db[&apos;cname&apos;] or db.cname</div><div class="line">        db.getCollectionInfos([filter]) - returns a list that contains the names</div><div class="line"> and options of the db&apos;s collections</div><div class="line">        db.getCollectionNames()</div><div class="line">        db.getLastError() - just returns the err msg string</div><div class="line">        db.getLastErrorObj() - return full status object</div><div class="line">        db.getLogComponents()</div><div class="line">        db.getMongo() get the server connection object</div><div class="line">        db.getMongo().setSlaveOk() allow queries on a replication slave server</div><div class="line">        db.getName()</div><div class="line">        db.getPrevError()</div><div class="line">        db.getProfilingLevel() - deprecated</div><div class="line">        db.getProfilingStatus() - returns if profiling is on and slow threshold</div><div class="line">        db.getReplicationInfo()</div><div class="line">        db.getSiblingDB(name) get the db at the same server as this one</div><div class="line">        db.getWriteConcern() - returns the write concern used for any operations</div><div class="line"> on this db, inherited from server object if set</div><div class="line">        db.hostInfo() get details about the server&apos;s host</div><div class="line">        db.isMaster() check replica primary status</div><div class="line">        db.killOp(opid) kills the current operation in the db</div><div class="line">        db.listCommands() lists all the db commands</div><div class="line">        db.loadServerScripts() loads all the scripts in db.system.js</div><div class="line">        db.logout()</div><div class="line">        db.printCollectionStats()</div><div class="line">        db.printReplicationInfo()</div><div class="line">        db.printShardingStatus()</div><div class="line">        db.printSlaveReplicationInfo()</div><div class="line">        db.dropUser(username)</div><div class="line">        db.repairDatabase()</div><div class="line">        db.resetError()</div><div class="line">        db.runCommand(cmdObj) run a database command.  if cmdObj is a string, tu</div><div class="line">rns it into &#123; cmdObj : 1 &#125;</div><div class="line">        db.serverStatus()</div><div class="line">        db.setLogLevel(level,&lt;component&gt;)</div><div class="line">        db.setProfilingLevel(level,&lt;slowms&gt;) 0=off 1=slow 2=all</div><div class="line">        db.setWriteConcern( &lt;write concern doc&gt; ) - sets the write concern for w</div><div class="line">rites to the db</div><div class="line">        db.unsetWriteConcern( &lt;write concern doc&gt; ) - unsets the write concern f</div><div class="line">or writes to the db</div><div class="line">        db.setVerboseShell(flag) display extra information in shell output</div><div class="line">        db.shutdownServer()</div><div class="line">        db.stats()</div><div class="line">        db.version() current version of the server</div></pre></td></tr></table></figure></p>
<p>###mongodb权威指南第二版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">1. 键不能包含\0（空字符），此被保留作为键的结尾</div><div class="line"></div><div class="line">2. .和$作为保留字符有特殊意义</div><div class="line"></div><div class="line">3. 以下划线_开头的键呗保留但是没有严格的限制</div><div class="line"></div><div class="line">4. 区分类型和大小写</div><div class="line"></div><div class="line">5. 不能有重复的键</div><div class="line"></div><div class="line">6. 集合名不能以system.开头，此为系统保留前缀</div><div class="line"></div><div class="line">7. 子集合用.分开命名空间</div><div class="line"></div><div class="line">8. GridFS是一种存储大文件的协议，使用子集合来存储文件的元数据，这样就与内容块分开了（具体后面）</div><div class="line"></div><div class="line">9. 驱动提供语法糖访问子集合</div><div class="line"></div><div class="line">10. mongodb的web控制台通过子集合的方式将数据组织在DBTOP部分（具体后面）</div><div class="line"></div><div class="line">11. 数据库名规则：不能空串，不能含空格/\和系统保留字符，小写，最多64字符</div><div class="line"></div><div class="line">12. 数据库名admin（root数据库），local（用于存储本地单台服务器的任意集合），config（分片设置时保存分片设置的相关信息）的数据库是保留数据库</div><div class="line"></div><div class="line">13. 子集合的券命名长度在实际使用中不能超过100字节</div><div class="line"></div><div class="line">14. 启动mongo&gt;&gt;&gt;mongod.exe</div><div class="line"></div><div class="line">15. 占用端口加1000的端口可以用来获取mongo的数据库管理信息</div><div class="line"></div><div class="line">16. 运行shell，&gt; ./mongo,shell在启动时自动连接mongodb服务器，顾启动前要先启动mongod，shell是功能完备的JS解释器，可以运行任何JS程序</div><div class="line"></div><div class="line">17. shell启动时连接到mongo的test数据库，这个数据库连接赋值给全局变量db，这个变量是通过shell访问mongodb的主要入口点</div><div class="line"></div><div class="line">18. 提供非js语法的扩展语法糖，如：&gt;use [db name]选择要使用的数据库，&gt;db 查看指向的数据库，可以通过变量名访问集合，进行CRUD操作（创读更新删）</div></pre></td></tr></table></figure></p>
<p>19.<img src="img/20170117104513.jpg" alt=""><br><img src="img/20170117104752.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">20. 使用如db.foo.update可看到内置的函数，故集合名应避免与之重名，因为会优先找属性其次才是集合，使用db.getCollection(&quot;version&quot;)可以确保得到集合</div><div class="line"></div><div class="line">21. 迭代对每个子集合操作：</div><div class="line">for(i in collection)&#123;</div><div class="line">    doStuff(db.blog[collection[i]])</div><div class="line">&#125;</div><div class="line"></div><div class="line">22. mongodb通常支持的数据类型：null，bool，32/64整数，64浮点，字符串，符号，对象id，日期，正则，代码，二进制数据，最大值最小值（BSON的特殊类型表示可能的最大最小值，shell中没有这个类型），未定义类型，数组，内嵌文档</div><div class="line"></div><div class="line">23. shell默认是64位双精度，在使用shell读取后保存的数字会隐式的被转为双精度，所以不要在shell下覆盖整个文档</div></pre></td></tr></table></figure></p>
<p><img src="img/20170117153237.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">24. Date()返回对日期的字符串表示，new Date()返回的是Date对象，日期在数据中没有时区信息，都是以标准纪元毫秒数存储。</div><div class="line"></div><div class="line">25. mongodb中存储的文档必须要有一个_id，此键可以使任何类型的，默认是个ObjectId对象，_id在一个集合里不能重复，但是在其他集合中可以有与这个集合_id重复的。ObjectId是_id的默认类型，轻量型，不同机器都能用全局唯一的同种方法生成它，使用12字节的存储空间，每个字节为两位十六进制数字，是个24位字符串</div></pre></td></tr></table></figure></p>
<p><img src="img/20170117173040.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">不过最近在网上看到有说这个是有可能重复的，我觉得理论上也是有这个可能的，不过只要不是公开的数据库，自己理清也就没什么问题了。</div><div class="line"></div><div class="line">26. insert()插入操作，批量插入大小有限制，数据最终以BSON形式存于数据库解析BSON时只检验是否包含_id和文档大小不超过4MB(书上写的，现版本不一定)。允许插入无效数据。在启动数据库服务器的时候使用--objcheck选项会在插入钱检查文档结构的有效性（会牺牲性能）。使用Object.bsonsize(doc)查看文档转为bson后的大小，执行插入时不执行代码，所以也没有注入攻击的可能。</div><div class="line"></div><div class="line">27. remove()删除集合中的文档单不删除集合本身，remove()可以接受一个查询文档作为可选参数来进行条件删除，删除数据是永久性的，不能撤销不能恢复。使用drop_collection()不能带条件，整个集合都删除，但是是直接清空间，效率比remove()高</div><div class="line"></div><div class="line">28. update()两个参数，一个是查询文档，一个是修改器。</div><div class="line">文档替换：找到文档后直接给目标赋值，之后使用update()填入文档和修改的数据修改器中使用如&#123;&quot;$inc&quot;:&#123;&quot;pageviews&quot;:1&#125;&#125;,是增值加1，使用修改器时_id的值不能改变。</div><div class="line"></div><div class="line">$set新增信息，$unset删除信息如&#123;&quot;$unset&quot;:&#123;&quot;pageviews&quot;:1&#125;&#125;，$inc也能建不存在的值，专用于对整数长整数双精度浮点数，使用null，bool，数字字符会被转成数字。</div><div class="line"></div><div class="line">$push在数组后加值若数组不存在则会创建数组。$ne判断值是否存在，不存在在加入：db.papers.update(&#123;&quot;authors cites&quot;:&#123;&quot;$ne&quot;:&quot;Richie&quot;&#125;&#125;,&#123;$push:&#123;&quot;authors cited&quot;:&quot;Richie&quot;&#125;&#125;)。</div><div class="line"></div><div class="line">$addToSet用来避免重复加入:db.users.update(&#123;&quot;_id&quot;:ObjectId(&quot;xxxxxxxxxxxxxxxxxxxxxx&quot;)&#125;,&#123;&quot;$addToSet&quot;:&#123;&quot;emails&quot;:&#123;&quot;$each&quot;:&quot;12345&quot;,&quot;12345&quot;，&quot;12345&quot;&#125;&#125;&#125;)，结合$each可以一次添加多个。</div><div class="line"></div><div class="line">$pop从数组中删除元素：&#123;$pop:&#123;key:-1&#125;&#125;，正数从后开始，负数从前开始</div><div class="line"></div><div class="line">$pull带条件的删除，db.lists.update(&#123;&#125;,&#123;&quot;$pull&quot;:&#123;&quot;todo&quot;:&quot;laundry&quot;&#125;&#125;)</div><div class="line"></div><div class="line">通过位置或定位操作符$进行部分操作，使用$的如下：</div><div class="line">db.blog.update(&#123;&quot;post&quot;:&quot;post_id&quot;&#125;,&#123;&quot;$set&quot;:&#123;&quot;connect.$author&quot;:&quot;Jim&quot;&#125;&#125;)</div><div class="line">定位符只更新第一个匹配的元素</div><div class="line"></div><div class="line">$inc不改变文档大小，速度快，$set会改变文档大小，速度慢</div><div class="line"></div><div class="line">$upsert要是没有文档符合更新条件会创建文档，有的话是更新/shell的save函数也是在文档不存在时插入，存在时更新，有一个文档参数，如果文档含有_id，则shell调用upsert，否则调用插入</div><div class="line"></div><div class="line">更新多个文档，update的第4个参数写true更新所有匹配到的文档</div><div class="line"></div><div class="line">runCommand(&#123;getLastError:1&#125;)查看更新的文档数量，返回的n的值就是</div><div class="line"></div><div class="line">findAndModify会等待数据库响应，适用于原子性操作避免竞态：</div><div class="line">db.runCommand(&#123;&quot;findAndModify&quot;:&quot;processes&quot;,&quot;query&quot;:&#123;&quot;status&quot;:&quot;READY&quot;&#125;,&quot;sort&quot;:&#123;&quot;priority&quot;:-1&#125;,&quot;update&quot;:&#123;&quot;$set&quot;:&#123;&quot;status&quot;:&quot;RUNNING&quot;&#125;&#125;&#125;)</div><div class="line">findAndModify值为集合名，query查询条件，sort排序条件，必须有一个update或remove，new表示返回更新前还是更新后的文档，默认为更新前的</div><div class="line"></div><div class="line">29.插入删除更新都是立即完成的，速度快但受网络和服务器影响，使用getLastError可以检查执行是否成功，来进行一些安全操作，但会牺牲性能</div><div class="line"></div><div class="line">30.find()条件查询</div><div class="line"></div><div class="line">限制范围的查询：</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>$lt</th>
<th>$lte</th>
<th>$gt</th>
<th>$gte</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td>&lt;=</td>
<td>&gt;</td>
<td>&gt;=</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">$in查询一个键的多个值,或匹配，$or也是，还能含有其他条件</div><div class="line">$nin如上取反</div><div class="line">$mod取模</div><div class="line">$not取反</div><div class="line"></div><div class="line">修改器取外层文档键，条件句取内层文档键</div><div class="line"></div><div class="line">null返回匹配null的文档，不存在的和缺少这个键的文档，如只想要匹配值为null的文档，还要检查是否值为null，通过$exists判断键值是否存在</div><div class="line"></div><div class="line">使用Perl兼容的正则表达式库，可以为前缀型正则表达式查询创建索引，正则可以匹配到自身</div><div class="line"></div><div class="line">$all通过多个元素匹配数组&#123;$all:[&quot;x1&quot;,&quot;x2&quot;]&#125;，和匹配</div><div class="line"></div><div class="line">$size长度范围：db.blog.findone(criteria,&#123;&quot;$size&quot;:3&#125;)</div><div class="line"></div><div class="line">$slice返回部分：db.blog.findone(criteria,&#123;&quot;comments&quot;:&#123;&quot;$slice&quot;:10&#125;&#125;)返回前10条，-10返回后10条,&#123;20,10&#125;从第21个开始取10个</div><div class="line"></div><div class="line">查询内嵌文档，使用如commects.author这种键直接可以点出来</div><div class="line"></div><div class="line">$eleMatch指定一组条件：db.blog.findone(&quot;comments&quot;:&#123;&quot;$eleMatch&quot;:&#123;&quot;author&quot;:&quot;joe&quot;,&quot;score&quot;:&#123;&quot;$gte&quot;:5&#125;&#125;&#125;)</div><div class="line"></div><div class="line">$where,比较难说清，例子吧：</div><div class="line">db.foo.find(&#123;&quot;$where&quot;:function()&#123;</div><div class="line">    for(var current in this)&#123;</div><div class="line">        for(var other in this)&#123;</div><div class="line">            if(current != other &amp;&amp; this[current] == this[other])&#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;return false;</div><div class="line">&#125;&#125;);</div><div class="line">会很吃内存和性能，尽量避免使用，但是我觉得可以通过对文档设计上的细分和减少类似递归这类复杂度高的算法来减少性能上的损失，因为即使是避免，在有些情况下还是在所难免。</div><div class="line"></div><div class="line">31.数据库使用游标来返回find结果，将查询结果分配给一个局部变量声明的var，如：</div><div class="line">while (cursor.hasNext())&#123;</div><div class="line">    obj = cursor.next();</div><div class="line">    ~~~</div><div class="line">&#125;;</div><div class="line">next()用来迭代结果，hasNext()检查是否有后续结果</div><div class="line">又如：</div><div class="line">var cursor = db.people.find();</div><div class="line">cursor.forEach(function(x)&#123;</div><div class="line">    print(x.name);</div><div class="line">&#125;);</div><div class="line">这是游标的迭代接口</div><div class="line"></div><div class="line">调用find时shell不立即执行查询，在真正开始要求获得过节时才发送查询，在执行前可以附加额外选项，游标对象方法几乎都是返回游标自身，所以可以链式调用。查询呗发往服务器shell立刻获取前100个结果或前4MB数据中较少的一个，这段数据用光后shell会再连数据库要求更多结果，这一过程一直会持续到游标耗尽或全部结果返回</div><div class="line"></div><div class="line">32.db.c.find().limit(3)限制返回3个结果上限</div><div class="line">db.c.find().skip(3)限制略过前3个结果</div><div class="line">db.c.find().sort(&#123;username:1,age:-1&#125;)按username升序age降序排序</div><div class="line">综合：db.stock.find(&#123;&quot;desc&quot;:&quot;mp3&quot;&#125;).limit(50).skip(50).sort(&#123;&quot;price&quot;:-1&#125;)</div><div class="line">一页50结果的第二页结果，price降序</div><div class="line"></div><div class="line">33.mongoDB中处理不同类型的数据的顺序，对混合类型键排序顺序如下：</div></pre></td></tr></table></figure>
<p><img src="img/20170120115636.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">skip省略大量结果时拖性能，顾因尽量避免，如：</div><div class="line">while(page1.hasNext())&#123;</div><div class="line">    latest = page1.next();</div><div class="line">    display(lastst);</div><div class="line">&#125;;</div><div class="line">var page2 = db.foo.find(&#123;&quot;data&quot;:&#123;&quot;$gt&quot;:latest.date&#125;&#125;);</div><div class="line">page2.sort(&#123;&quot;date&quot;:-1&#125;).limit(100);</div><div class="line"></div><div class="line">随机抽取文档：使用取随机数的函数</div><div class="line">var random = Math.random();</div><div class="line">db.foo.findOne(&quot;random&quot;:random);</div><div class="line"></div><div class="line">建立包含随机键的索引：</div><div class="line">db.people.ensureIndex(&#123;&quot;profession&quot;:1,&quot;state&quot;:1,&quot;rsndom&quot;:1&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="img/20170120123219.jpg" alt=""><br><img src="img/20170120123252.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">34.对文档操作后文档增大，再存回数据库时会导致文档空间位置移位导致性能损耗，应对的办法是对查询对象进行快照。如使用$snapshot选项，查询就是针对不变的集合视图运行，所有返回一致结果的查询实际上都进行了快照，不一致只在游标等待结果时集合内容被改变的情况下发生</div><div class="line"></div><div class="line">游标在服务端消耗内存和其他资源，终止时会释放游标资源，完成匹配结果，游标客户端不在作用域内，10分钟不使用时会销毁自身释放资源，大多数驱动可以使用innortal函数设置游标是否可超时</div><div class="line"></div><div class="line">35.建立索引，使用ensureIndex()方法，插件索引会对加速该键的查询，对其他键无作用，即使是包含有这个键：</div><div class="line">db.ensureIndex(&#123;&quot;date&quot;:1,&quot;username&quot;:1&#125;),-1则为降序</div><div class="line">创建索引对插入更新删除会产生额外的消耗，因为还要排序，每个集合的默认最大索引数为64个</div><div class="line"></div><div class="line">explain()查看查询有关数据，在查询后面跟上此方法即可，必须在最后面</div></pre></td></tr></table></figure></p>
<p><img src="img/20170122120249.png" alt=""><br><img src="img/20170122120340.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">使用hint()可强制使用指定索引,但如果索引性能不高就很耗性能了</div></pre></td></tr></table></figure></p>
<p><img src="img/20170121230735.png" alt=""><br><img src="img/20170121230752.png" alt=""><br><img src="img/20170121230929.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$操作符用于索引效率很低，取反也是</div><div class="line"></div><div class="line">$or查询：</div><div class="line">db.foo.find(&#123;&quot;$or&quot;:[&#123;&quot;x&quot;:123&#125;,&#123;&quot;y&quot;:456&#125;]&#125;)</div><div class="line">是将两次查询的结果合并所以效率也不是很高</div><div class="line"></div><div class="line">索引对象</div><div class="line">db.people.ensureIndex(&#123;&quot;xxx.city&quot;:1&#125;)</div><div class="line"></div><div class="line">索引数组</div></pre></td></tr></table></figure></p>
<p><img src="img/20170122111908.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">所以对数组的索引基本上在意识中就不要有，除非是专门使用数组中指定的某一个</div><div class="line"></div><div class="line">如果索引的键在某个文档中是一个数组，那么这个索引就会被标记为多键索引，如果使用多键索引，explain()时isMultikey值为true，一旦被标记为多键索引就无法再变成非多键索引，唯一的方法就是删除重建</div><div class="line"></div><div class="line">索引基数：基数是集合中某个字段拥有不同值的数量，键的基数越高，这个键上的索引就越有用，所以，因在基数高的键上建立索引，基数高的也应该放在复合索引的前面。</div></pre></td></tr></table></figure></p>
<p><img src="img/20170122120833.png" alt=""><br>36.<br><img src="img/20170122121527.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">&#123;&quot;$natural&quot;:1&#125;指定文档按照磁盘上的顺序排列，强制全表扫描:</div><div class="line">db.entries.find(&#123;&quot;create_at&quot;:&#123;&quot;$lt&quot;:hourAgo&#125;&#125;).hint(&#123;&quot;$natural&quot;:1&#125;)</div><div class="line"></div><div class="line">因为是按照磁盘顺序，对于一个活跃的集合来说是无意义的，因为随文档体积变化，文档会在磁盘中移动，新文档会插入到空白处，</div><div class="line"></div><div class="line">37.索引类型：</div><div class="line">唯一索引:db.users.ensureIndex(&#123;username:1&#125;,&#123;&quot;unique&quot;:true&#125;)</div><div class="line"></div><div class="line">索引储桶大小有限制，所有字段必须小于1024字节才能包含在索引里，超出8kb大小的键不会受唯一索引的约束，可以插入多个同样的8KB长的字符串</div><div class="line"></div><div class="line">复合唯一索引，容易的不想讲</div><div class="line">去除重复：&#123;&quot;dropDups&quot;:true&#125;  和unique这个放在一个对象里</div><div class="line"></div><div class="line">稀疏索引</div><div class="line">当存在时，必须唯一,去掉unique就是普通的稀疏索引：</div><div class="line">db.users.ensureIndex(&#123;username:1&#125;,&#123;&quot;unique&quot;:true，&quot;sparse&quot;:true&#125;)</div><div class="line">38.</div><div class="line">删除索引：</div><div class="line">dropIndexes(),dropIndex()</div><div class="line">system.indexes查看索引原信息</div><div class="line">db.collectionName.getIndexes()查看给定集合上的所有索引的信息</div><div class="line"></div><div class="line">标识索引：db.users.ensureIndex(&#123;username:1&#125;,&#123;&quot;name&quot;:&quot;alphabet&quot;&#125;)</div><div class="line"></div><div class="line">新建索引时会阻塞对数据库的读写请求知道创建完成，指定background选项可在后台创建，可减少对性能的影响，但多少还是有的，在已有文档上创建索引会比新创建索引再插入文档要快一点</div><div class="line"></div><div class="line">39.固定集合，大小固定，新加入的在队列尾，加满会覆盖最老的那个类推，固定大小速度回快很多但是不灵活</div><div class="line"></div><div class="line">创建固定集合并限制文档数量;</div><div class="line">db.createCollection(&quot;my_collection&quot;,&#123;&quot;capped&quot;:true,&quot;size&quot;:1000000,&quot;max&quot;:100&#125;)</div><div class="line"></div><div class="line">常规集合转固定:</div><div class="line">&#123;&quot;convertToCapped&quot;:&quot;test&quot;&#125;</div><div class="line"></div><div class="line">自然排序：</div><div class="line">sort(&#123;&quot;$natural&quot;:1&#125;)</div><div class="line">按文档在磁盘上的顺序，也可以-1逆序</div><div class="line"></div><div class="line">循环游标，mongo shell中不能用不讲</div><div class="line"></div><div class="line">调用cereatCollection()创建集合时指定autoIndexId为false，这样就不会有_id索引，但是也就永远不能进行复制操作了，因为复制需要_id,_id一旦创建就无法删除，如果_id不合规范就只能删除集合重建</div><div class="line"></div><div class="line">TTL索引（time-to-live index）：</div><div class="line">为每个文档设置一个超时时间，达到设置的老化程度之后就会被删除，叫做老化移除系统(age-out system)</div><div class="line">db.users.ensureIndex(&#123;&quot;lastUpdated&quot;:1&#125;,&#123;&quot;expireAfterSecs&quot;:60*60*24&#125;&#125;</div><div class="line">比lastUpdated字段时间大expireAfterSecs秒时文档被删除</div><div class="line">mongoDB每分钟会对TTL索引惊醒一次清理，所以不应依赖秒为单位的时间保证索引的存活状态，使用collMod命令修改expireAfterSecs值：</div><div class="line">db.runCommand(&#123;&quot;collMod&quot;:&quot;someapp.cache&quot;,&quot;expireAfterSecs&quot;:3600&#125;)</div><div class="line">改为一小时清理一次</div><div class="line"></div><div class="line">40.全文本索引</div><div class="line">更高的成本，在频繁操作的集合上创建全文本索引可能导致mongoDB过载，所以使用要谨慎。使用全文本索引所有字符串会被分解，分词，并保存在一些地方，该集合所有操作性能会受影响</div><div class="line">db.adminCommand(&#123;&quot;setParameter&quot;:1,&quot;textSearchEnabled&quot;:true&#125;)</div></pre></td></tr></table></figure></p>
<p><img src="img/20170123115858.png" alt=""><br><img src="img/20170123115923.png" alt=""><br><img src="img/20170123120701.png" alt=""><br><img src="img/20170123121155.png" alt=""><br><img src="img/20170123121220.png" alt=""><br><img src="img/20170123133428.png" alt=""><br><img src="img/20170123133451.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">41.地理空间索引：2dsphere(经纬度型)索引和2d索引(平面坐标型和时间连续数据)</div><div class="line"></div><div class="line">2dsphere索引允许使用GeoJSON格式指定点，线和多边形：</div><div class="line">点：&#123;</div><div class="line">    &quot;name&quot;:&quot;New York City&quot;,</div><div class="line">    &quot;loc&quot;:&#123;</div><div class="line">        &quot;type&quot;:&quot;point&quot;,</div><div class="line">        &quot;coordinates&quot;:[50,2]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">线和多边形：&#123;</div><div class="line">    &quot;name&quot;:&quot;New York City&quot;,</div><div class="line">    &quot;loc&quot;:&#123;</div><div class="line">        &quot;type&quot;:&quot;Line&quot;,</div><div class="line">        &quot;coordinates&quot;:[[0,1],[0,2],[1,2]]</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">db.world.ensureIndex(&#123;&quot;loc&quot;:&quot;2dsphere&quot;&#125;)</div><div class="line"></div><div class="line">位置相交：</div><div class="line">var eastVillage = &#123;</div><div class="line">    &quot;type&quot;:&quot;Polygon&quot;,</div><div class="line">    &quot;coordinates&quot;:[</div><div class="line">        [-7498,7745],</div><div class="line">        [-7442,7797],</div><div class="line">        [-7456,7747],</div><div class="line">        [-7486,7754]</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">db.open.street.map.find(&#123;</div><div class="line">    &quot;loc&quot;:&#123;&quot;$geoIntersects&quot;:&#123;&quot;$geometry&quot;:eastVillage&#125;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">完全包含：</div><div class="line">db.open.street.map.find(&#123;</div><div class="line">    &quot;loc&quot;:&#123;&quot;$within&quot;:&#123;&quot;$geometry&quot;:eastVillage&#125;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">附近，会对结果按近到远的距离排序：</div><div class="line">db.open.street.map.find(&#123;</div><div class="line">    &quot;loc&quot;:&#123;&quot;$near&quot;:&#123;&quot;$geometry&quot;:eastVillage&#125;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">复合地理空间索引：</div><div class="line">db.open.street.map.find(&#123;</div><div class="line">    &quot;loc&quot;:&#123;&quot;$near&quot;:&#123;&quot;$geometry&quot;:eastVillage&#125;&#125;，</div><div class="line">    &quot;tags&quot;:&quot;pizza&quot;</div><div class="line">&#125;)</div><div class="line"></div><div class="line">2d索引：</div><div class="line">db.hyrule.ensureIndex(&#123;&quot;tile&quot;:&quot;2d&quot;&#125;)</div><div class="line">&#123;</div><div class="line">    &quot;name&quot;:&quot;Water Temple&quot;</div><div class="line">    &quot;tile&quot;:[32,32]</div><div class="line">&#125;</div><div class="line">只能进行点搜索</div><div class="line">设置边界值</div><div class="line">db.star.trek.ensureIndex(&#123;&quot;light-years&quot;:&quot;2d&quot;&#125;,&#123;&quot;min&quot;:-1000,&quot;max&quot;:1000&#125;)</div><div class="line">按照靠近的排序，默认最多返回100个文档，不需要这么多的话就给限制</div><div class="line">db.hyrule.find(&#123;&quot;tile&quot;:&#123;&quot;$near&quot;:[20,21]&#125;&#125;).limit(10)</div><div class="line">形状范围内</div><div class="line">db.hyrule.find(&#123;&quot;tile&quot;:&#123;&quot;$within&quot;:&#123;&quot;$box&quot;:[[10,20],[15,30]]&#125;&#125;&#125;)</div><div class="line">db.hyrule.find(&#123;&quot;tile&quot;:&#123;&quot;$within&quot;:&#123;&quot;$center&quot;:[[10,20],5]&#125;&#125;&#125;)</div><div class="line">db.hyrule.find(&#123;&quot;tile&quot;:&#123;&quot;$within&quot;:&#123;&quot;$polygon&quot;:[[0,20],[10,0],[-10,0]]&#125;&#125;&#125;)</div><div class="line"></div><div class="line">41.使用GridFS存储大型二进制文件：</div><div class="line">优点：可代替独立的文件存储工具，自动平衡已有的复制或为mongoDB设置自动分片，对文件存储做故障转移或横向扩展更容易，上传文件时可以更从容的解决其他一些文件系统可能遇到的问题，比如能在同一目录下存大量文件，集中度高，以2GB单位来分配数据文件。</div><div class="line">缺点：性能低，不如直接从文件系统中访问文件速度快。如果要修改这上面的文件只能讲已有的整个删除再重新保存，所以不能在同一时间对文件中的所有块加锁</div><div class="line">总结：对读多写少的可用</div><div class="line">使用mongofiles进行对GridFS的操作，这东西包含在mongoDB的发行版中</div></pre></td></tr></table></figure></p>
<p><img src="img/20170123174315.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">我觉的我的业务里用不上，这大概就是放放视频数据用了</div></pre></td></tr></table></figure></p>
<p><img src="img/20170123174523.png" alt=""><br><img src="img/20170123174541.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mongoDB不会对GridFS请求做特殊处理，所有处理都是由客户端的驱动程序和工具负责的</div><div class="line">理念：将大文件分成较大的块，将每个块作为独立的文档进行存储（想象一下B站看视频的时候是一段一段加载的那种），所以也是因此需要一个文档用来将这些块组织在一起并存储该文件的元信息</div><div class="line"></div><div class="line">块的默认使用集合：fs.chunks，可以改为其他的集合，如图：</div></pre></td></tr></table></figure></p>
<p><img src="img/20170123175043.png" alt=""><br><img src="img/20170123175110.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">42.聚合框架:</div><div class="line">使用构件创建pipcline管道，构件：filtering(筛选),projecting(投射),grouping(分组),sorting(排序),limiting(限制),skipping(跳过)</div><div class="line">长的例子如图：</div></pre></td></tr></table></figure></p>
<p><img src="img/20170123180404.png" alt=""><br><img src="img/20170123180436.png" alt=""><br><img src="img/20170123182143.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">43.管道操作符：</div><div class="line">$match,用于对文档集合进行筛选，之后可以在筛选得到的文档子集上做聚合，可以使用所有常规的查询操作符$gt,$lt,$in等，但不能使用地理空间操作符，实际使用中尽量将$match放在管道的前面使用这样可以减少管道的工作量，并且在投射和分组前执行的话在查询中可以使用索引</div><div class="line"></div><div class="line">$project，管道中的投射操作，可以从子文档中提取字段，可以重命名文档，可以在字段上进行操作</div><div class="line">如下返回文档中只包含一个&quot;author&quot;的字段：</div><div class="line">db.articles.aggregate(&#123;&quot;$project&quot;:&#123;&quot;author&quot;:1,&quot;_id&quot;:0&#125;&#125;)</div><div class="line">使用&quot;_id&quot;:0不返回_id，默认会返回</div><div class="line"></div><div class="line">将投射过的字段重命名：</div><div class="line">db.articles.aggregate(&#123;&quot;$project&quot;:&#123;&quot;userID&quot;:&quot;$_id&quot;,&quot;_id&quot;:0&#125;&#125;)</div></pre></td></tr></table></figure></p>
<p><img src="img/20170203181704.png" alt=""><br><img src="img/20170203182318.png" alt=""><br><img src="img/20170203182438.png" alt=""><br><img src="img/20170203183056.png" alt=""><br><img src="img/20170203183252.png" alt=""><br><img src="img/20170204102417.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$group将文档依据特定字段的不同值进行分组：</div><div class="line">&#123;&quot;$group&quot;:&#123;&quot;_id&quot;:&#123;&quot;state&quot;:&quot;$state&quot;,&quot;city&quot;:&quot;$city&quot;&#125;&#125;&#125;</div><div class="line">&#123;&quot;result&quot;:[&#123;&quot;_id&quot;:&quot;A+&quot;&#125;,&#123;&quot;_id&quot;:&quot;A&quot;&#125;,&#123;&quot;_id&quot;:&quot;B&quot;&#125;,&#123;&quot;_id&quot;:&quot;C&quot;&#125;,&#123;&quot;_id&quot;:&quot;D&quot;&#125;]&#125;</div></pre></td></tr></table></figure></p>
<p><img src="img/20170204110105.png" alt=""><br><img src="img/20170204111452.png" alt=""><br><img src="img/20170204113208.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$unwind，将数组中的没一个只拆分为单独的文档</div></pre></td></tr></table></figure></p>
<p><img src="img/20170204114102.png" alt=""><br><img src="img/20170204114155.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$sort，排序，值-1为逆序，和$group一样不能使用流式工作方法，在收到文档后才能进行排序，先在各个分片上排序然后将各个分片排序结果做进一步处理</div><div class="line"></div><div class="line">$limit，接受一个数值值返回结果集中前这个数值个文档</div><div class="line"></div><div class="line">$skip，接受一个数字丢弃结果集中前这个数字个文档，返回剩余的，也就是$limit的取反，大量跳过的时候回西安处理前面的文档导致效率低下，建议这种情况下先排序</div><div class="line"></div><div class="line">    使用管道前建议先去掉不必要的文档和字段以提高效率，管道不是从原有集合中使用数据就不能再筛选和排序中使用索引，mongoDB不允许单一的聚合操作占用过多的系统内存，如果mongoDB发现某个聚合操作占用内存20%以上这个操作就出出现输出错误，允许将输出结果利用管道放入一个集合中是为了方便以后使用，通过$match操作迅速减小结果集大小，使用管道进行实时聚合，由于管道会不断的包含更多的文档越来越复杂，所以几乎不可能实时得到管道的操作结果</div></pre></td></tr></table></figure></p>
<p>44.<br><img src="img/20170204123007.png" alt=""><br><img src="img/20170204150530.png" alt=""><br><img src="img/20170204150709.png" alt=""><br><img src="img/20170204152849.png" alt=""><br><img src="img/20170204154237.png" alt=""><br><img src="img/20170204155224.png" alt=""><br><img src="img/20170204155256.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">45.聚合命令:</div><div class="line"></div><div class="line">count</div><div class="line">返回总的文档数量：</div><div class="line">db.foo.count()</div><div class="line">db.foo.count(&#123;&quot;x&quot;:1&#125;)</div><div class="line">增加查询条件会使count变慢，可以使用索引但是没有足够的元素数据提供count使用，所以不如直接使用查询快</div><div class="line"></div><div class="line">distinct</div><div class="line">用来找出给定键的所有不同值，使用时必须指定集合和键：</div><div class="line">db.runCommand(&#123;&quot;distinct&quot;:&quot;people&quot;,&quot;key&quot;,&quot;age&quot;&#125;)</div><div class="line">//&#123;&quot;value&quot;[20,35,60],&quot;ok&quot;:1&#125;</div><div class="line"></div><div class="line">group</div><div class="line">先选定分组所依据的键，而后将集合依据选定键的不同值分成若干组，然后对没一个分组内的文档进行聚合，和SQL的group by差不多</div></pre></td></tr></table></figure></p>
<p><img src="img/20170204172724.png" alt=""><br><img src="img/20170204174512.png" alt=""><br><img src="img/20170204175934.png" alt=""><br><img src="img/20170204180005.png" alt=""><br><img src="img/20170204180027.png" alt=""></p>
<p>46.<br><img src="img/20170204181015.png" alt=""><br><img src="img/20170204181202.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    总的来说，范式化就是说文档少，类似传统关系型单表查询，适合用于数据多读频繁写不频繁，数据增量少，数据不定期改变的数据；反范式化适合用于写频繁读不频繁，数据增量大，数据经常改变，中间数据也需要一致的数据，类似传统关系型的多表查询，因为读数据的时候会使用多个文档所以读性能低，但写的时候只需要改变特定的文档，重写的数据少所以需要在具体业务中权衡两者之间的性能极限，当然，还是需要在计算平衡后写测试用例去实测性能。</div><div class="line">    </div><div class="line">47.</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206101351.jpg" alt=""><br><img src="img/20170206101436.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">48.优化数据操作包括对读操作中正确使用索引，尽可能将所有信息放在单个文档中返回，对写操作中减少索引数量以及尽可能提高更新效率，包括读写的重要性和频率都是要考虑的因素，这段和我上面自己写的差不多啊，不过是提炼的书上的原话。</div><div class="line"></div><div class="line">优化文档增长，预留足够空间，原因前面提到过文档大小在mongo中有大小，超过会文档移动</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206104124.jpg" alt=""><br><img src="img/20170206104155.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">49.数据库和集合的设计</div><div class="line">    相近模式的文档应放在相同集合中，mongo通常不允许使用多个几个进行数据组合，如有些文档需要进行集中查询或聚合，那么这些文档应该放在同一个大集合里。结构非常不同的文档要进行聚合就需要让他们位于同一个集合内。</div><div class="line">    按照数据集的重要性将数据集放在不同的磁盘上，比如重要且不大的用户数据可以放在SSD磁盘上，对用户集合使用PAID10，对不太重要的集合使用RAID0。使用多个数据库是，mongo通常不允许直接将数据从一个数据库一刀另一个数据库，例如无法将A库中的MapReduce结果保存到B库中，也无法使用renameCollection命令将集合从一个库移动到另一个库，如：</div><div class="line">    foo.a-&gt;foo.b OK</div><div class="line">    foo.a-&gt;fox.a NO</div></pre></td></tr></table></figure></p>
<p>50.</p>
<p><img src="img/20170206113846.jpg" alt=""><br><img src="img/20170206113905.jpg" alt=""><br><img src="img/20170206113941.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    一致性管理主要是说数据库连接的顺序和不同连接之间异步操作对数据一致性的影响，一个shell一个连接，多个shell同时的操作会导致对同一个库操作的数据在时间差上会导致数据后来的操作读到之前的数据，同一个连接的操作是顺序执行的，有一个操作队列进行管理</div><div class="line">    模式迁移讲数据库在使用中应对改变时的策略，保存该程序的没一个模式，有保证改变模式后的数据库能在新旧版本的程序中都能够使用，增加版本号字段，模式变化时数据迁移三种办法，个人觉得最好的是第一种，视情况选择了。</div><div class="line">    不适合使用mongo的场景中说的不支持事务并不是真正的不支持，只是要做到相当的复杂，多维数据连接也同理，硬要这样做的话，会导致时间复杂度以O^n的程度增加，这是关系型数据库擅长的领域。</div><div class="line"></div><div class="line">51.建立副本集</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206121755.jpg" alt=""><br><img src="img/20170206121943.jpg" alt=""><br><img src="img/20170206122429.jpg" alt=""><br><img src="img/20170206122451.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">启动一个不连接到任何mongod的shell：</div><div class="line">mongo --nodb</div><div class="line">创建一个副本集(包含三个服务器的副本集)：</div><div class="line">replicaSet = new ReplSetTest(&#123;&quot;nodes&quot;:3&#125;)</div><div class="line">启动三个mongod进程：</div><div class="line">replicaSet.startSet()</div><div class="line">配置复制功能：</div><div class="line">replicaSet.initiate()</div><div class="line">查看副本集状态：</div><div class="line">xxxDB.isMaster()</div><div class="line">连接到备份节点：</div><div class="line">conn2 = new Mongo(&quot;localhost:31001&quot;)</div><div class="line">secondaryDB - conn2.getDB(&quot;test&quot;)</div><div class="line">设置可从备份节点读取数据(对连接设置的)：</div><div class="line">conn2.setSlaveOk()</div><div class="line">关闭副本集：</div><div class="line">replicaSet.stopSet()</div><div class="line"></div><div class="line">备份节点只通过复制功能写入，不能直接接受客户端的写入请求，使用自动故障转移当主节点挂掉的时候其中的一个备份节点会自动选为主节点，验证：</div><div class="line"></div><div class="line">xxxDB.adminCommand(&#123;&quot;shutdown&quot;:1&#125;)</div><div class="line">xxxcopyDB.isMaster()时主节点已经移动</div><div class="line"></div><div class="line">注意：</div><div class="line">客户端在单台服务器上可以执行的请求都可以发送到主节点执行（读写执行命令创建索引），客户端不能在备份节点上写操作，默认下客户端不能从备份节点中读操作，需要设置setSlaveOk()</div><div class="line"></div><div class="line">52.配置副本集</div><div class="line"></div><div class="line">假设一个运行在sever-1:27017上的单个mongod实例，为副本选定一个任一UTF-8字符的名字，之后使用--replSet name选项重启server-1，例如：</div><div class="line">mongod --replSet spock -f mongod.conf --fork</div><div class="line">再启动两个mongod服务器作为副本集中的其他成员：</div><div class="line">ssh serber-2</div><div class="line">server-2$ mongod --replSet spock -f mongod.conf --fork</div><div class="line">server-2$ exit</div><div class="line">ssh serber-3</div><div class="line">server-3$ mongod --replSet spock -f mongod.conf --fork</div><div class="line">server-3$ exit</div><div class="line">将后两个成员添加到副本集中，他们就是自动复制成员一的数据，将replSet选项添加到每个成员各自的mongod.conf文件中，以后启动时就是自动使用这个选项</div><div class="line">创建文件让mongod知道其他成员的存在，在配置文件中列出每个成员，并将配置文件发送给server-1，有server-1负责将配置文件传播给其他成员，在shell中文档如下：</div><div class="line">config = &#123;</div><div class="line">    &quot;_id&quot;:&quot;spock&quot;,</div><div class="line">    &quot;members&quot;:[</div><div class="line">        &#123;&quot;_id&quot;:0,&quot;host&quot;:&quot;server-1:27017&quot;&#125;,</div><div class="line">        &#123;&quot;_id&quot;:1,&quot;host&quot;:&quot;server-2:27017&quot;&#125;,</div><div class="line">        &#123;&quot;_id&quot;:2,&quot;host&quot;:&quot;server-3:27017&quot;&#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">_id字段的值是启动时从命令性传递进来的副本集的名称(本例为spock)，要保证这个名称与启动传入的名字一致。然后把这个配置对象发送给其中一个成员：</div><div class="line">db = (new Mongo(&quot;server-1:27017&quot;)).getBd(&quot;test&quot;)//连接server-1</div><div class="line">rs.initiate(config)//初始化副本集</div><div class="line">&#123;</div><div class="line">    &quot;info&quot;:&quot;Config now saved locally&quot;,</div><div class="line">    &quot;ok&quot;:1</div><div class="line">&#125;</div><div class="line">之后server-1解析配置对象想其他成员发送消息所有成员配置后会自动选出一个主节点。如果创建的是一个全系拿到副本集，可以将配置文件发送给副本集的任一一个成员，如果已有一个有数据的成员，那么就必须将数据对象发送给这个拥有数据的成员，如果不止一个拥有数据的成员，那么就无法初始化副本集。必须用mongo shell来配置副本集，没有其他方法可以基于文件对副本集进行配置</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206145211.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">53.修改副本集配置</div><div class="line">为副本集添加新成员：</div><div class="line">rs.add(&quot;server-4:27017&quot;)</div><div class="line">从副本集中删除成员：</div><div class="line">rs.remove(&quot;server-1:27017&quot;)</div><div class="line"></div><div class="line">    删除成员或其他除添加成员之外的行为时，会在shell中得到很多无法连接到数据库的错误信息，这些都是正常的，侧面说明修改成功了，重新配置副本集时作为重新配置过程中的最后一步，主节点会关闭所有连接因此shell会短暂断开然后自动重连。重新配置副本集时主节点先退化为普通备份节点，然后恢复，重新配置副本集之后副本集中会暂时没有主节点，之后会回复，使用rs.config()查看配置修改是否成功，每次修改时，version字段会自增，初始为1</div><div class="line"></div><div class="line">修改现有成员，在shell中创建新的配置文档，然后调用rs.reconfig：</div><div class="line">var config = rs.config()</div><div class="line">config.members[1].host = &quot;server-2:27017&quot;</div><div class="line">rs.reconfig(config)</div><div class="line"></div><div class="line">    对于复杂的配置，reconfig通常比add和remove更有用</div><div class="line"></div><div class="line">54.</div></pre></td></tr></table></figure>
<p><img src="img/20170206152525.jpg" alt=""><br><img src="img/20170206152703.jpg" alt=""><br><img src="img/20170206153105.jpg" alt=""><br><img src="img/20170206153411.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">55.成员配置选项</div><div class="line">    让某个成员拥有优先成为主节点的权力或者让某个成员对客户端不可见使无法将读写请求发送给他，这时候就要用成员配置选项</div><div class="line">    仲裁者唯一作用参与选举，不保存数据，不为客户端提供服务，只为帮助成员数量少的副本达成成为大多数的条件</div><div class="line">    因为仲裁者不需要履行传统mongod服务器的责任，所以可以作为轻量级进程在垃圾服务器上运行，如果可以，应该讲仲裁者放在单独的故障域中与其他成员分开，这样就能以外部视角看待副本集中的成员了</div><div class="line">启动仲裁者：</div><div class="line">rs.addArb(&quot;server-5:27017&quot;)</div><div class="line">在成员配置中指定arbiterOnly选项，与上面的效果是一样的：</div><div class="line">rs.add(&#123;&quot;_id&quot;:4,&quot;host&quot;:&quot;server-5:27017&quot;,&quot;arbiterOnly&quot;:true&#125;)</div><div class="line">成员一旦以仲裁的身份添加到副本集中就永远只能是仲裁，非仲裁也不能改为仲裁，添加仲裁以避免出现偶数个节点不能达到大多数的问题</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206163604.jpg" alt=""><br><img src="img/20170206164056.jpg" alt=""><br><img src="img/20170206164129.jpg" alt=""><br><img src="img/20170206165237.jpg" alt=""><br><img src="img/20170206170924.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">56.同步</div><div class="line">    mongo的复制功能是使用操作日志oplog实现的没操作日志包含主节点的每一次写操作，是主节点的local数据库中的一个固定的集合，备份节点通过查询这个集合就可以知道需要进行复制的操作</div><div class="line">    每个备份的节点维护自己的oplog记录每一次从主节点的复制操作，这样每个成员都可以作为同步源提供给其他成员使用</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206180325.jpg" alt=""><br><img src="img/20170206180625.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(1)首先，这个成员做一些记录钱的准备，选择一个成员作为同步源，在local.me中为自己创建一个标识符，删除所有已存在的数据库，以一个全新状态开始进行同步</div></pre></td></tr></table></figure></p>
<p><img src="img/20170206181140.jpg" alt=""><br><img src="img/20170206181452.jpg" alt=""><br><img src="img/20170206233805.jpg" alt=""><br><img src="img/20170206234159.jpg" alt=""><br><img src="img/20170206234610.jpg" alt=""><br><img src="img/20170206234811.jpg" alt=""><br><img src="img/20170207000401.jpg" alt=""><br><img src="img/20170207000438.jpg" alt=""><br><img src="img/20170207000502.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">57.客户端到副本集的连接</div><div class="line">    默认连接到主节点，副本集在后台默默处理热备份，在驱动程序中使用与MongoClient等价的对象，并提供一个希望连接到副本集种子列表，种子是副本集成员，并不需要将所有的成员都列出来，驱动程序连接到某个种子服务器之后就嗯呢狗狗得到其他成员的地址，一个常用的连接字符串如下所示：</div><div class="line">    &quot;mongodb://server-1:27017,server-2:27017&quot;</div><div class="line">    主节点挂掉后驱动会尽快找到新的主节点，如果没有可达的主节点，应用程序就无法执行写操作</div><div class="line">    主节点暂时不可用，默认情况下驱动程序在这段时间内不会处理任何请求，但是可能选择将读请求路由到备份节点</div><div class="line">    驱动程序能将没有主节点的情况隐瞒一段时间但不能在没有主节点的情况下长久存在，如果有操作失败了，驱动就知道是主节点挂了，但是无法知道主节点在挂掉之前是否已经正确处理本次请求，所以，用户需要来解决这样的问题：</div><div class="line">    如果新主节点被选出，要不要再新的主节点上重新操作，是否要假设最后一次请求已经被旧的主节点处理完成，是否要检查新的主节点以确保它同步了最后的操作</div><div class="line">    通常，驱动程序没有办法判断某次操作是否在服务器崩溃之前成功处理，但是应用程序可以自己实现相应的解决方案，比如查询每次记录所在文档的_id</div><div class="line">    在挂掉的情况下因为主节点切换和时间竞争问题导致的各个副本之间有不一致的操作时，备份节点会撤销与主节点不一致的操作，并写入回滚文件中，之后让用户来判断这些操作要不要加到主节点上，在用户处理之前这些操作就消失了，写入时指定majority可以避免这种情况的发生，如果应用程序最初使用&quot;w&quot;:&quot;majority&quot;，</div></pre></td></tr></table></figure>
<p><img src="img/20170207111548.jpg" alt=""><br><img src="img/20170207111707.jpg" alt=""><br><img src="img/20170207143336.jpg" alt=""><br><img src="img/20170207143416.jpg" alt=""><br><img src="img/20170207181010.jpg" alt=""><br><img src="img/20170207182045.jpg" alt=""><br><img src="img/20170208115023.jpg" alt=""><br><img src="img/20170208115806.jpg" alt=""><br><img src="img/20170208123747.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">58.单机模式启动成员</div><div class="line">    重启成员服务器，让它成为一个单机运行的服务器为不再是一个副本集成员，查看参数：</div><div class="line">    db.serverCmdLineOpts()</div><div class="line">    重启时不使用repSet选项，这样他就会成为一个单机的mongod，可以对其进行读和写不希望副本集中对其他服务器联系到这台服务器可以让它监听不同的端口，最后保持dbpath的值不变，因为重启后要对这台服务器的数据做一些操作，最终使用如下启动服务器;</div><div class="line">    mongod --port 30000 --dbpath /var/lib/db</div><div class="line">    此时此服务器一再单机模式中运行，监听30000端口的请求，副本集中其他成员会试图连接它的27017端口所以他们无法连接到这台服务器会认为它已经挂了</div><div class="line">    当这台服务器上执行完维护工作后，可以以最原始的参数重新启动它，启动后他会自动与副本集中的其他成员进行同步，静维护期间缺失的操作复制回来</div><div class="line">    </div><div class="line">59.副本集配置</div><div class="line">    副本集配置以一个文档的形式保存在local.system.repSet集合中，副本集中的所有成员的这个文档都是相同的，不要使用update更新这个文档，应该使用rs辅助函数或者repSetReconfig命令来修改副本集配置</div><div class="line">    </div><div class="line">创建副本集：</div><div class="line">启动所有成员服务器，之后使用rs.initiate将配置传递给其中的一个成员</div><div class="line">var config = &#123;</div><div class="line">    &quot;_id&quot;:setName,</div><div class="line">    &quot;member&quot;:[</div><div class="line">        &#123;&quot;_id&quot;:0,&quot;host&quot;:host1&#125;,</div><div class="line">        &#123;&quot;_id&quot;:1,&quot;host&quot;:host2&#125;,</div><div class="line">        &#123;&quot;_id&quot;:2,&quot;host&quot;:host3&#125;</div><div class="line">    ]</div><div class="line">&#125;</div><div class="line">rs.initiate(config)</div><div class="line">对副本集中的一个成员使用initiate即可，收到命令的成员会自动将配置文件传递给副本集中的其他成员</div><div class="line">下面的总觉得全是重复的，直接截图了，都要会背了。。。</div></pre></td></tr></table></figure>
<p><img src="img/20170208161141.jpg" alt=""><br><img src="img/20170208161635.jpg" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">修改成员状态：</div><div class="line">主节点变备份节点：</div><div class="line">re.stepDown()</div><div class="line">re.stepDown(600)指定持续10分钟</div><div class="line"></div><div class="line">阻止选举：</div><div class="line">rs.freeze(10000)指定持续10000秒</div><div class="line">rs.freeze(0)解除阻止</div></pre></td></tr></table></figure></p>
<p><img src="img/20170208162957.jpg" alt=""><br><img src="img/20170208163925.jpg" alt=""><br><img src="img/20170208164023.jpg" alt=""><br><img src="img/20170208164238.jpg" alt=""><br><img src="img/20170208165303.jpg" alt=""><br><img src="img/20170208165805.jpg" alt=""><br><img src="img/20170208170219.jpg" alt=""><br><img src="img/20170208172859.jpg" alt=""><br><img src="img/20170208182034.jpg" alt=""><br><img src="img/20170209105659.jpg" alt=""><br><img src="img/20170209112907.jpg" alt=""><br><img src="img/20170209114942.jpg" alt=""><br><img src="img/20170209115848.jpg" alt=""><br><img src="img/20170209115910.jpg" alt=""><br><img src="img/20170209141908.jpg" alt=""><br><img src="img/20170209114942.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">60.分片：</div><div class="line">快速建立一个简单的集群：</div><div class="line">启动mongo shell：</div><div class="line">mogo --nodb</div><div class="line"></div><div class="line">使用ShardingTest类创建集群：</div><div class="line">cluster = new ShardingTest(&#123;&quot;shards&quot;:3,&quot;chunksize&quot;:1&#125;)</div><div class="line">创建一个3个分片的集群分别在30000,30001,30002端口</div><div class="line"></div><div class="line">默认在30999端口启动mongos，连接到这个端口使用集群：</div><div class="line">db = (new Mongo(&quot;localhost:30999&quot;)).getDB(&quot;test&quot;)</div><div class="line">向mongos发送的请求会自动转发到合适的分片上</div><div class="line"></div><div class="line">对集合的数据库启用分片：</div><div class="line">sh.enableSharding(&quot;test&quot;)</div><div class="line"></div><div class="line">在作为片键的键上创建索引：</div><div class="line">db.users.ensureindex(&#123;&quot;username&quot;:1&#125;)</div><div class="line"></div><div class="line">之后依据username对集合分片：</div><div class="line">sh.shardCollection(&quot;test.users&quot;,&#123;&quot;username&quot;:1&#125;)</div><div class="line"></div><div class="line">关闭集群：</div><div class="line">cluster.stop()</div></pre></td></tr></table></figure>
<p><img src="img/20170209151001.jpg" alt=""></p>
<p><img src="img/20170209155003.jpg" alt=""><br><img src="img/20170209161037.jpg" alt=""><br><img src="img/20170209161259.jpg" alt=""><br><img src="img/20170209161445.jpg" alt=""><br><img src="img/20170209161610.jpg" alt=""><br><img src="img/20170209161655.jpg" alt=""><br><img src="img/20170209162603.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">61.配置分片</div></pre></td></tr></table></figure>
<p><img src="img/20170209165007.jpg" alt=""><br><img src="img/20170209170042.jpg" alt=""><br><img src="img/20170213174044.jpg" alt=""><br><img src="img/20170213180133.jpg" alt=""><br><img src="img/20170213180155.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://jumpu.top/2017/02/15/MongoDB doucment/" data-id="ciz6pa20q0000sgkwtren1w8d" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB-nosql-sql/">DB nosql sql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MEAN-mongoDB-express-nodeJS-angular/">MEAN mongoDB express nodeJS angular</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MEAN-nodeJS/">MEAN nodeJS</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/DB-nosql-sql/" style="font-size: 10px;">DB nosql sql</a> <a href="/tags/MEAN-mongoDB-express-nodeJS-angular/" style="font-size: 10px;">MEAN mongoDB express nodeJS angular</a> <a href="/tags/MEAN-nodeJS/" style="font-size: 10px;">MEAN nodeJS</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/02/15/ionic2build/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/02/15/MongoDB doucment/">database_choice</a>
          </li>
        
          <li>
            <a href="/2017/02/15/testone/">testone</a>
          </li>
        
          <li>
            <a href="/2017/02/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2017/01/16/MEAN本地服务器安装/">MEAN本地服务器安装</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 AN.<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>